import{_ as t,o,c as a,ag as s}from"./chunks/framework.DtpOrGl6.js";const r="/mcpconnect/assets/mcp-architecture.Daap7Npz.png",g=JSON.parse('{"title":"Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"introduction.md","filePath":"introduction.md","lastUpdated":1771778582000}'),n={name:"introduction.md"};function i(c,e,l,d,h,p){return o(),a("div",null,[...e[0]||(e[0]=[s('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">‚Äã</a></h1><h2 id="what-is-mcp" tabindex="-1">What is MCP? <a class="header-anchor" href="#what-is-mcp" aria-label="Permalink to &quot;What is MCP?&quot;">‚Äã</a></h2><p>The Model Context Protocol (MCP) is an open standard for connecting large language models (LLMs) to external tools and data.</p><p>It enables AI models to go beyond their training data by accessing new information, performing actions, and interacting with tools and databases.</p><p><img src="'+r+'" alt="MCP architecture"></p><p>With MCP servers you can:</p><ul><li>Provide functionality through <code>Tools</code> (used to execute code or otherwise produce a side effect)</li><li>Expose data through <code>Resources</code> (used to load information into the LLM&#39;s context)</li><li>Define interaction through <code>Prompts</code> (reusable templates for LLM interactions)</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>For a complete reference of the protocol itself, see the <a href="https://modelcontextprotocol.io/docs/getting-started/intro" target="_blank" rel="noreferrer">official MCP documentation</a>.</p></div><h2 id="what-is-mcpconnect" tabindex="-1">What is MCPConnect? <a class="header-anchor" href="#what-is-mcpconnect" aria-label="Permalink to &quot;What is MCPConnect?&quot;">‚Äã</a></h2><p><strong>Delphi MCP Connect (MCPConnect)</strong> is a lightweight yet robust framework designed to drastically simplify the creation of <strong>Model Context Protocol (MCP) Servers</strong> using Embarcadero Delphi. By leveraging the power of <strong>Attributes</strong>, the framework allows developers to re-use existing business logic and standard Delphi classes, turning them into protocol-aware server components with minimal boilerplate code.</p><p>MCPConnect handles the serialization, routing, and context management required for the server-side implementation of the MCP protocol.</p><h2 id="highlights" tabindex="-1">Highlights <a class="header-anchor" href="#highlights" aria-label="Permalink to &quot;Highlights&quot;">‚Äã</a></h2><ul><li>üõ°Ô∏è <strong>Type safety</strong> ‚Äî Define your tool arguments as native Delphi classes or records; MCPConnect handles the rest.</li><li>üöõ <strong>Transports</strong> ‚Äî Built-in HTTP (WebBroker, Indy) and STDIO transports for both stateless and persistent connections.</li><li>üóÇÔ∏è <strong>Session Management</strong> ‚Äî Built-in stateful session support across requests with automatic cleanup and custom session data.</li><li>‚ö° <strong>Low boilerplate</strong> ‚Äî MCPConnect generates all the MCP endpoints for you, apart from your tools, prompts and resources.</li></ul><h2 id="key-features" tabindex="-1">Key Features <a class="header-anchor" href="#key-features" aria-label="Permalink to &quot;Key Features&quot;">‚Äã</a></h2><ul><li><strong>Attribute-Driven Development</strong> ‚Äî Simply register classes to automatically discover tools, resources, and prompts using the <code>[McpTool]</code>, <code>[McpResource]</code>, <code>[McpPrompt]</code> attributes to expose specific methods.</li><li><strong>Standard Code Re-use</strong> ‚Äî Easily expose existing business logic classes without heavy modification or complex inheritance hierarchies.</li><li><strong>Automatic Routing</strong> ‚Äî The framework automatically scans and registers methods decorated with the appropriate attributes, handling all request routing.</li><li><strong>Easy-to-use classes</strong> for tools, prompts, and resources.</li><li><strong>Session Management</strong> ‚Äî Thread-safe session support with configurable timeout, automatic cleanup, and support for both generic (<code>TJSONObject</code>) and custom typed session data. Sessions are automatically injected via the <code>[Context]</code> attribute.</li><li><strong>API-Key authentication</strong> for HTTP transport.</li><li><strong>JSON-RPC</strong> ‚Äî MCPConnect contains a comprehensive, high-performance JSON-RPC 2.0 library (<code>JRPC</code>) built specifically for Delphi.</li><li><strong>Automatic JSON Schema generation</strong> ‚Äî Using the powerful Neon <code>TSchemaGenerator</code>, MCPConnect supports any Delphi type as parameter or result.</li></ul>',15)])])}const m=t(n,[["render",i]]);export{g as __pageData,m as default};
