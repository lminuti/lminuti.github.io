import{_ as a,o as s,c as t,ag as i}from"./chunks/framework.DEqXEGcv.js";const k=JSON.parse('{"title":"Authentication","description":"","frontmatter":{},"headers":[],"relativePath":"authentication.md","filePath":"authentication.md","lastUpdated":1772228606000}'),n={name:"authentication.md"};function o(r,e,l,h,c,d){return s(),t("div",null,[...e[0]||(e[0]=[i(`<h1 id="authentication" tabindex="-1">Authentication <a class="header-anchor" href="#authentication" aria-label="Permalink to &quot;Authentication&quot;">â€‹</a></h1><p>MCPConnect supports token-based authentication for HTTP transports (WebBroker and Indy). While authorization for MCP servers is optional, it is strongly recommended in the following scenarios:</p><ul><li>The server accesses user-specific data (emails, documents, databases)</li><li>You need to audit who performed specific actions</li><li>The server exposes APIs that require explicit user consent</li><li>You are building for enterprise environments with strict access controls</li><li>You want to implement per-user rate limiting or usage tracking</li></ul><p>For HTTP-based transports, MCPConnect currently supports token-based authentication only. OAuth flows are typically designed for remotely hosted servers accessed over HTTP; however, OAuth is not currently supported by MCPConnect.</p><div class="info custom-block"><p class="custom-block-title"><strong>ðŸ’¡ Authorization for Local MCP Servers</strong></p><p>Authentication is not applicable to STDIO transport in the traditional network sense, since no network communication is involved â€” the MCP client launches the server process directly and communicates through its stdin/stdout pipes. However, local MCP servers using STDIO can still implement authorization by leveraging environment-based credentials or credentials provided by embedded third-party libraries. Because a STDIO-based MCP server runs locally, it can adopt flexible approaches for acquiring and validating user credentials, which may or may not rely on browser-based authentication flows.</p></div><p>When authentication is configured, the server checks every incoming request for a valid token before processing it. Requests that do not carry the expected token are rejected with an authentication error.</p><h2 id="the-iauthtokenconfig-plugin" tabindex="-1">The IAuthTokenConfig Plugin <a class="header-anchor" href="#the-iauthtokenconfig-plugin" aria-label="Permalink to &quot;The IAuthTokenConfig Plugin&quot;">â€‹</a></h2><p>Authentication is configured through the <code>IAuthTokenConfig</code> plugin. Add <code>MCPConnect.Configuration.Auth</code> to the uses clause:</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uses</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  MCPConnect.Configuration.Auth;</span></span></code></pre></div><p>Then configure the plugin on your <code>TJRPCServer</code> instance:</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FJRPCServer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .Plugin.Configure&lt;IAuthTokenConfig&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetToken(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-secret-token&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .ApplyConfig;</span></span></code></pre></div><p>The token is compared case-sensitively against each incoming request. The default extraction method is Bearer token (see below).</p><h2 id="token-location-modes" tabindex="-1">Token Location Modes <a class="header-anchor" href="#token-location-modes" aria-label="Permalink to &quot;Token Location Modes&quot;">â€‹</a></h2><p>The <code>TAuthTokenLocation</code> enum controls where the server looks for the token in the HTTP request. Three modes are available:</p><h3 id="bearer-default" tabindex="-1">Bearer (default) <a class="header-anchor" href="#bearer-default" aria-label="Permalink to &quot;Bearer (default)&quot;">â€‹</a></h3><p>The token is extracted from the standard <code>Authorization</code> HTTP header using the Bearer scheme. This is the default when <code>SetTokenLocation</code> is not called.</p><p>The client must include the following header in every request:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Authorization: Bearer my-secret-token</span></span></code></pre></div><h3 id="custom-header" tabindex="-1">Custom Header <a class="header-anchor" href="#custom-header" aria-label="Permalink to &quot;Custom Header&quot;">â€‹</a></h3><p>The token is read from an arbitrary HTTP header whose name you specify with <code>SetTokenCustomHeader</code>.</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FJRPCServer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .Plugin.Configure&lt;IAuthTokenConfig&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetToken(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-api-key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetTokenLocation(TAuthTokenLocation.Header)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetTokenCustomHeader(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;X-API-Key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .ApplyConfig;</span></span></code></pre></div><p>The client must send:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>X-API-Key: my-api-key</span></span></code></pre></div><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">â€‹</a></h3><p>The token is read from an HTTP cookie. Specify the cookie name with <code>SetTokenCustomHeader</code>.</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FJRPCServer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .Plugin.Configure&lt;IAuthTokenConfig&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetToken(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-session-value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetTokenLocation(TAuthTokenLocation.Cookie)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .SetTokenCustomHeader(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;SessionId&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .ApplyConfig;</span></span></code></pre></div><p>The client must send:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cookie: SessionId=my-session-value</span></span></code></pre></div><h2 id="api-reference" tabindex="-1">API Reference <a class="header-anchor" href="#api-reference" aria-label="Permalink to &quot;API Reference&quot;">â€‹</a></h2><table tabindex="0"><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><code>SetToken(token)</code></td><td>The token string the server will compare against (case-sensitive)</td></tr><tr><td><code>SetTokenLocation(location)</code></td><td>Where to extract the token: <code>Bearer</code> (default), <code>Header</code>, <code>Cookie</code></td></tr><tr><td><code>SetTokenCustomHeader(name)</code></td><td>Header or cookie name; required for <code>Header</code> and <code>Cookie</code> modes, ignored for <code>Bearer</code></td></tr></tbody></table>`,30)])])}const u=a(n,[["render",o]]);export{k as __pageData,u as default};
