import{_ as a,o as i,c as e,ag as t}from"./chunks/framework.DtpOrGl6.js";const c=JSON.parse('{"title":"JSON-RPC","description":"","frontmatter":{},"headers":[],"relativePath":"jrpc.md","filePath":"jrpc.md","lastUpdated":1772228606000}'),n={name:"jrpc.md"};function l(p,s,h,r,d,o){return i(),e("div",null,[...s[0]||(s[0]=[t(`<h1 id="json-rpc" tabindex="-1">JSON-RPC <a class="header-anchor" href="#json-rpc" aria-label="Permalink to &quot;JSON-RPC&quot;">​</a></h1><h2 id="what-is-json-rpc" tabindex="-1">What is JSON-RPC? <a class="header-anchor" href="#what-is-json-rpc" aria-label="Permalink to &quot;What is JSON-RPC?&quot;">​</a></h2><p>JSON-RPC is a lightweight, transport-agnostic remote procedure call protocol. It uses JSON as its data format and is designed to be simple: a client sends a request object identifying a method and its parameters, and the server replies with either a result or an error.</p><p>The MCP protocol is built entirely on top of JSON-RPC 2.0 — every tool call, resource read, and initialization handshake is a JSON-RPC message. MCPConnect handles all of this transparently; you never need to touch the protocol layer when building MCP servers.</p><h2 id="jrpc-—-the-embedded-json-rpc-library" tabindex="-1">JRPC — The Embedded JSON-RPC Library <a class="header-anchor" href="#jrpc-—-the-embedded-json-rpc-library" aria-label="Permalink to &quot;JRPC — The Embedded JSON-RPC Library&quot;">​</a></h2><p>MCPConnect includes a full JSON-RPC 2.0 implementation called <strong>JRPC</strong>. It can also be used independently of MCP for any Delphi project that needs RPC communication:</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uses</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  MCPConnect.JRPC.Core;</span></span></code></pre></div><h2 id="defining-a-json-rpc-api" tabindex="-1">Defining a JSON-RPC API <a class="header-anchor" href="#defining-a-json-rpc-api" aria-label="Permalink to &quot;Defining a JSON-RPC API&quot;">​</a></h2><p>Annotate a class with <code>[JRPC(&#39;namespace&#39;)]</code> to group its methods under a common prefix. Mark individual methods with <code>[JRPCMethod(&#39;name&#39;)]</code> and parameters with <code>[JRPCParam(&#39;name&#39;)]</code>:</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uses</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  MCPConnect.JRPC.Core;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[JRPC(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TMathApi = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [JRPCMethod(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;sum&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [JRPCParam(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] A,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [JRPCParam(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] B: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [JRPCMethod(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;echo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EchoString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [JRPCParam(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AValue: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [JRPCMethod(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;timestamp&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetCurrentTimestamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: TDateTime;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Methods are addressed as <code>namespace/methodname</code> (e.g. <code>math/sum</code>). Return values and parameters are marshaled automatically via Neon.</p><h2 id="registering-classes" tabindex="-1">Registering Classes <a class="header-anchor" href="#registering-classes" aria-label="Permalink to &quot;Registering Classes&quot;">​</a></h2><p>Register API classes in the global <code>TJRPCRegistry</code> — typically in the <code>initialization</code> section of the unit:</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">initialization</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  TJRPCRegistry.Instance.RegisterClass(TMathApi);</span></span></code></pre></div><h2 id="server-setup" tabindex="-1">Server Setup <a class="header-anchor" href="#server-setup" aria-label="Permalink to &quot;Server Setup&quot;">​</a></h2><p>Wire the registry to the HTTP transport with <code>TJRPCServer</code> and <code>TJRPCDispatcher</code> (same components used for MCP):</p><div class="language-pascal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">pascal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">procedure</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TWebModule1.WebModuleCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Sender: TObject);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FJRPCServer := TJRPCServer.Create(Self);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FJRPCDispatcher := TJRPCDispatcher.Create(Self);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FJRPCDispatcher.PathInfo := </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/jrpc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FJRPCDispatcher.Server := FJRPCServer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>The endpoint is then available at <code>/jrpc</code> and accepts standard JSON-RPC 2.0 POST requests.</p><h2 id="error-handling" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h2><p>Raise <code>EJRPCException</code> (or a subclass) from any method to return a structured JSON-RPC error response. JRPC maps Delphi exceptions to the standard error codes automatically:</p><table tabindex="0"><thead><tr><th>Exception class</th><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td><code>EJRPCException</code></td><td>-32603</td><td>Internal error (default)</td></tr><tr><td><code>EJRPCParseError</code></td><td>-32700</td><td>Invalid JSON received</td></tr><tr><td><code>EJRPCInvalidRequestError</code></td><td>-32600</td><td>Request is not a valid JSON-RPC object</td></tr><tr><td><code>EJRPCMethodNotFoundError</code></td><td>-32601</td><td>Method does not exist</td></tr><tr><td><code>EJRPCInvalidParamsError</code></td><td>-32602</td><td>Invalid parameters</td></tr></tbody></table>`,21)])])}const E=a(n,[["render",l]]);export{c as __pageData,E as default};
